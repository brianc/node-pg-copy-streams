// Generated by CoffeeScript 1.10.0
var CopyToQueryStream, Transform, codes, eventTypes, protocolHelper,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Transform = require('stream').Transform;

codes = require('./codes');

protocolHelper = require('./protocolHelper');

eventTypes = ['close', 'data', 'end', 'error'];

module.exports = CopyToQueryStream = (function(superClass) {
  extend(CopyToQueryStream, superClass);

  function CopyToQueryStream(text, options) {
    this.text = text;
    Transform.call(this, options);
    this._listeners = {};
    this.rowCount = 0;
    this.firstPass = true;
    this.remainder = false;
  }

  CopyToQueryStream.prototype.shiftMessage = protocolHelper.shiftMessage;

  CopyToQueryStream.prototype.cleanStream = function(chunk) {
    this.connection.stream.pause();
    this._detach();
    this.connection.stream.unshift(chunk);
    this.push(null);
    return this.connection.stream.resume();
  };

  CopyToQueryStream.prototype.submit = function(connection) {
    this.connection = connection;
    this.connection.query(this.text);
    eventTypes.forEach((function(_this) {
      return function(type) {
        _this._listeners[type] = _this.connection.stream.listeners(type);
        return _this.connection.stream.removeAllListeners(type);
      };
    })(this));
    return this.connection.stream.pipe(this);
  };

  CopyToQueryStream.prototype.handleError = function(e) {
    return this.emit('error', e);
  };

  CopyToQueryStream.prototype.handleCommandComplete = function() {};

  CopyToQueryStream.prototype.handleReadyForQuery = function() {};

  CopyToQueryStream.prototype._detach = function() {
    this.connection.stream.unpipe();
    return eventTypes.forEach((function(_this) {
      return function(type) {
        _this.connection.stream.removeAllListeners(type);
        return _this._listeners[type].forEach(function(listener) {
          return _this.connection.stream.on(type, listener);
        });
      };
    })(this));
  };

  CopyToQueryStream.prototype._transform = function(chunk, enc, cb) {
    var code, error, length, message, ref;
    if (chunk && this.remainder) {
      chunk = Buffer.concat([this.remainder, chunk]);
    }
    while (true) {
      ref = this.shiftMessage(chunk), code = ref.code, length = ref.length, message = ref.message, chunk = ref.chunk;
      if (this.firstPass) {
        this.firstPass = false;
        if (code !== codes.copyOutResponse) {
          if (code === codes.error) {
            error = this.connection.parseE(message);
            this.emit('error', error);
          } else {
            this.emit('error', new Error("First message was not a copy out response"));
          }
          return cb();
        }
        continue;
      }
      switch (code) {
        case codes.copyData:
          this.push(message);
          continue;
        case null:
          this.remainder = chunk;
          return cb();
        case codes.copyDone:
          this.cleanStream(chunk);
          continue;
        case codes.close:
          this.rowCount = parseInt(message.slice(5, -1).toString('utf8'), 10);
          return cb();
        case codes.error:
          this.cleanStream(chunk);
          this.emit('error', new Error("Error during copy: " + message));
          return cb();
        case codes.noticeResponse:
        case codes.parameterStatus:
        case codes.notificationResponse:
          continue;
        default:
          this.emit('error', new Error("Received unexpected code: " + code));
          return cb();
      }
    }
  };

  return CopyToQueryStream;

})(Transform);
