// Generated by CoffeeScript 1.10.0
describe('copy to', function() {
  var async, concat, copyTo;
  async = require('async');
  concat = require('concat-stream');
  copyTo = require('../src/').to;
  it('should set up a correct highWaterMark', function() {
    var stream, txt;
    txt = "COPY (SELECT * FROM generate_series(0, 10)) TO STDOUT";
    stream = copyTo(txt, {
      highWaterMark: 10
    });
    return expect(stream._readableState.highWaterMark).to.equal(10);
  });
  it('should return the correct rows', function(done) {
    var client, stream, txt;
    client = getClient();
    txt = "COPY (SELECT * from generate_series(0, 999)) TO STDOUT";
    stream = client.query(copyTo(txt));
    stream.on('end', function() {
      return client.end();
    });
    return stream.pipe(concat(function(buf) {
      var expected, i, res, results;
      res = buf.toString('utf8');
      expected = (function() {
        results = [];
        for (i = 0; i < 1000; i++){ results.push(i); }
        return results;
      }).apply(this).join('\n') + '\n';
      expect(res).to.equal(expected);
      expect(stream.rowCount).to.equal(1000);
      return done();
    }));
  });
  it('should not leak listeners between calls', function(done) {
    var client, nClose, nData, nEnd, nError, runStream, txt;
    client = getClient();
    nClose = client.connection.stream.listeners('close').length;
    nData = client.connection.stream.listeners('data').length;
    nEnd = client.connection.stream.listeners('end').length;
    nError = client.connection.stream.listeners('error').length;
    if (client.connection.ssl) {
      nClose -= 1;
    }
    txt = "COPY (SELECT 10) TO STDOUT";
    runStream = function(num, cb) {
      var stream;
      stream = client.query(copyTo(txt));
      stream.on('data', function(data) {});
      stream.on('end', cb);
      return stream.on('error', cb);
    };
    return async.timesSeries(5, runStream, function(err) {
      expect(err).to.be["null"];
      client.end();
      expect(client.connection.stream.listeners('close').length).to.equal(nClose);
      expect(client.connection.stream.listeners('data').length).to.equal(nData);
      expect(client.connection.stream.listeners('end').length).to.equal(nEnd);
      expect(client.connection.stream.listeners('error').length).to.equal(nError);
      return done();
    });
  });
  it('should error when a query is cancelled inside Postgres', function(done) {
    var cancelClient, client, runStream;
    client = getClient();
    cancelClient = getClient();
    runStream = function(cb) {
      var c, stream, txt;
      txt = "COPY (SELECT pg_sleep(10)) TO STDOUT";
      stream = client.query(copyTo(txt));
      stream.on('data', function(data) {});
      stream.on('error', cb);
      c = function() {
        return cancelClient.query("SELECT pg_cancel_backend(pid)\nFROM pg_stat_activity\nWHERE query ~ 'pg_sleep'\n AND NOT query ~ 'pg_cancel_backend'");
      };
      return setTimeout(c, 25);
    };
    return runStream(function(err) {
      expect(err).to.not.be["null"];
      client.end();
      cancelClient.end();
      return done();
    });
  });
  it('should pass back error from bad query', function(done) {
    var client, stream, txt;
    client = getClient();
    txt = 'copy (select a_column from table_doesnt_exist) to STDOUT';
    stream = client.query(copyTo(txt));
    stream.on('data', function() {});
    return stream.on('error', function(err) {
      expect(err).to.not.be["null"];
      expect(err.message).to.equal('relation "table_doesnt_exist" does not exist');
      return done();
    });
  });
  return it('should deal with really large messages', function(done) {
    var client, stream, txt;
    client = getClient();
    txt = "COPY (SELECT lpad('', 1000000, 'a')) TO STDOUT";
    stream = client.query(copyTo(txt));
    stream.on('end', function() {
      return client.end();
    });
    return stream.pipe(concat(function(buf) {
      var res;
      res = buf.toString('utf8');
      expect(res.length).to.equal(1000001);
      return done();
    }));
  });
});
